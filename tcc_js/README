This is a JS port of tcc_1_7. Easiest way to run is via node.js from the
parent directory, ie:

cd ..
./mk_tcc_js

This port runs under Spidermonkey, node.js and Duktape. Note currently you need
node.js to actually output the binary to disk. When running under other js VMs
it will compile into memory and then check the sha256sum is the known correct
value.

To run the tests:

./run_test.sh

You will notice that test9 will fail. To fix that you will need a copy of
tcc_boot.o for test9.c that has been built with tcc_1_7. To build that:

cd ..
./mk_min
cd tcc_js
../tcc_1_7/a.out -r test9.c

When tcc_1_7 is run with the -r flag it will run the c file, but also dump a
compiled version of the c file called tcc_boot.o (hadcoded filename, this is an
adhoc executable format).

The reason test9.js will fail without tcc_boot.o is because it will attempt to
compare the real tcc_boot.o with the in memory version generated by the js
version of tcc.

To test building tcc run:

js test-tcc.js

Note you must also build a copy of tcc_boot.o using the c version of tcc
otherwise it will complain that it can't find tcc_boot.o to compare. To fix:

../tcc_1_7/a.out -r test-dlsym_wrap.c

Note there is a lot of debug output when running this version. This is useful
when developing. If you want it to be queiter (and quicker) you can temporarily
use stub versions of print and to_hex (see build-tcc.js).

Currently build-tcc.js can only be run from node.js. This limitation is lazyness
as the only reason it fails under SM is because SM doesn't have fs.writeFileSync
 . At some point I'll add a fs.writeFileSync for SM. To run build-tcc.js:

node node_compat_min.js build-tcc.js

dev notes:
==========

The compiler itself consists of tcc.js and i386-gen.js . These were created by
commenting out every line of the c version and then manually porting line by
line to JS. support.js contains a bunch of support functions along with a
primitive minimal libc implementation.

gen_metadata.c and mk_metadata.sh are just a convenient way to convert
enum/defines into JS variables in metadata.js . These could have been converted
manually, but it was easier to just autogenerate. The 110 line metadata.js file
is checked into the repo.

When developing it is useful to have a native version of tcc_1_7 in order to
compare behaviour between the c version and the js version. It is also useful to
be able to compare the binary output (the js version should produce bit
identical output). When building a native version it is also useful to have good
debug info so you can step through the code and compare data structures using
gdb. For this we need a native version built with gcc. To build with gcc:

cd ../tcc_1_7
gcc -m32 -g -nostdinc -I . dlsym_wrap.c

The dialect of JS used in tcc.js is a subset of JS that is pretty close to a
subset of c. There are no objects, only functions, integers, and memory
operations. All memory operations go via memory access functions (ri8, wi8,
ri32, wi32) to a virtual heap. There is also the concept of a virtual stack and
virtual frames. Function local stack allocations can be done via alloca. In
order to allocate and free stack frames we must explicitly enter and exit stack
frames via the enter and leave functions. eg:

function foo(a,b){
  enter(); // this allocates a stack frame
  var c=alloca(4); // this allocates a value on the stack
  var d;
  wi32(c,b); // copy value of b into c
  return leave(ri32(c)+a); // frees the stack frame and returns its argument
}

Code was converted incrementally from C to JS. To allow this I use a function
called "err" to stub out unimplemented code. err simply prints a backtrace and
throws an error eg:

function bar(){
  if(foo){
err(); // this branch of the if has not been ported
//  commented out C code
//  return 3;
  } else {
    return 7;
  }
}

Any file writes will go to an in memory virtual filesystem (just an object
called vfs). eg to read out tcc_boot.o just do vfs["tcc_boot.o"]

The "check" function in support.js will check the sha256sum of tcc_boot.o and
optionally check if the in memory file matches the on disk file. If there is a
mismatch it will print out where the files differ.
