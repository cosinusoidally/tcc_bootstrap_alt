WIP documenting the bootstrap process.

This documents the bootstrap process. Essentially this is an English description
of what ./mk_from_bootstrap_seed does in order to go from nothing all the way up
to tcc-0.9.27.

Build kaem-optional-seed and hex0-seed
======================================
The early stages of the boostrap use the early stages of stage0-posix:

https://github.com/oriansj/stage0-posix

Specifically it uses a partial in-tree copy of stage0-posix-x86

stage0 starts with 2 binary artifacts:

hex0-seed - a commented hex dump to binary converter
kaem-optional-seed - a very simple command interpreter

I do not include the binary artifacts. I instead convert them from source to
binary using my ./mk_seeds script. The ./mk_seeds script uses a couple of
simple unix utilites to convert x86/hex0_x86.hex0 into hex0-seed and
x86/kaem-minimal.hex0 into kaem-optional-seed

Run kaem-optional-seed
======================
Next mk_from_bootstrap_seed runs kaem-optional-seed . Since
kaem-optional-seed is run with no arguments it will the by default run kaem.x86.

Build hex0
==========
This rebuilds hex0 with hex0-seed. Not strictly necessary, but just for
verification purposes it is done.

Build kaem-optional-seed
========================
This rebuilds kaem-0 with hex0-seed. Not strictly necessary, but just for
verification purposes it is done.

Build hex1 using hex0
====================
hex1 is a step up from from hex0. It adds single character absolute or relative
labels.

Build hex2 using hex1
=====================
hex2 is a step up from from hex1. It adds multi-character absolute or relative
labels.

Build catm using hex2
=====================
catm is used to concatinate files. The idea is to avoid needing any tools from
the host so we need basic things like cat. catm differs from cat as the first
argument is actually the output file (rather than the last).

Build M0 using hex2
===================
M0 is a simple macro language that allows us to implement a simple assembler. Up
until this point all programs have been provided as a hex dump of the machine
code.

The output from M0 is hex2 code. If you are aware of a typical C compilation
process you will know it tends to go:

C into C compiler outputs assembly language
Assembly Language into assembler outputs object code (machine code)
Object code into the linker then produces the final executable

Or more concisely: compile, assemble, link

In our setup M0 is the assembler and hex2 is the linker. Next step is to
build a compiler.

Build cc_x86 using M0 and hex2
==============================


