WIP documenting the bootstrap process.

This documents the bootstrap process. Essentially this is an English description
of what ./mk_from_bootstrap_seed does in order to go from nothing all the way up
to tcc-0.9.27.

Build kaem-optional-seed and hex0-seed
======================================
The early stages of the boostrap use the early stages of stage0-posix:

https://github.com/oriansj/stage0-posix

Specifically it uses a partial in-tree copy of stage0-posix-x86

stage0 starts with 2 binary artifacts:

hex0-seed - a commented hex dump to binary converter
kaem-optional-seed - a very simple command interpreter

I do not include the binary artifacts. I instead convert them from source to
binary using my ./mk_seeds script. The ./mk_seeds script uses a couple of
simple unix utilites to convert x86/hex0_x86.hex0 into hex0-seed and
x86/kaem-minimal.hex0 into kaem-optional-seed

Run kaem-optional-seed
======================
Next mk_from_bootstrap_seed runs kaem-optional-seed . Since
kaem-optional-seed is run with no arguments it will the by default run kaem.x86.

Build hex0
==========
This rebuilds hex0 with hex0-seed. Not strictly necessary, but just for
verification purposes it is done.

Build kaem-optional-seed
========================
This rebuilds kaem-0 with hex0-seed. Not strictly necessary, but just for
verification purposes it is done.

Build hex1 using hex0
====================
hex1 is a step up from from hex0. It adds single character absolute or relative
labels.

Build hex2 using hex1
=====================
hex2 is a step up from from hex1. It adds multi-character absolute or relative
labels.

Build catm using hex2
=====================
catm is used to concatinate files. The idea is to avoid needing any tools from
the host so we need basic things like cat. catm differs from cat as the first
argument is actually the output file (rather than the last).

Build M0 using hex2
===================
M0 is a simple macro language that allows us to implement a simple assembler. Up
until this point all programs have been provided as a hex dump of the machine
code.

The output from M0 is hex2 code. If you are aware of a typical C compilation
process you will know it tends to go:

C into C compiler outputs assembly language
Assembly Language into assembler outputs object code (machine code)
Object code into the linker then produces the final executable

Or more concisely: compile, assemble, link

In our setup M0 is the assembler and hex2 is the linker. Next step is to
build a compiler.

Build cc_x86 using M0 and hex2
==============================
cc_x86 is a C compiler written in M0 macro assembly. Lets break down the whole
build process from x86/mescc-tools-mini-kaem.kaem :

./x86/bin/M0 ./x86/cc_x86.M1 ./x86/artifact/cc_x86-0.hex2
cc_x86.M1 is the source code of the C compiler. Note the extension is actually
M1 rather than M0. M0 is just a cut down version of the M1 macro language. The
same extension is used in both cases even though cc_x86.M1 will be in the M0
subset.

This step translates the assembly language version of cc_x86 into hex2

./x86/bin/catm ./x86/artifact/cc_x86-1.hex2 ./x86/ELF-i386.hex2 ./x86/artifact/cc_x86-0.hex2
This step adds the elf header to the hex2 output. Note the output file from catm
is the first argument (./x86/artifact/cc_x86-1.hex2)

./x86/bin/hex2-0 ./x86/artifact/cc_x86-1.hex2 ./x86/bin/cc_x86
This takes the hex2 code and outputs the binary version of cc_x86

Run after.kaem
==============
Our subset of stage0 has now finished so it now executes after.kaem. From this
point forward we are starting the main part of the tcc bootstrap process that
was designed in this repo.


