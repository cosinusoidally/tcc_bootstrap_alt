WIP documenting the bootstrap process.

This documents the bootstrap process. Essentially this is an English description
of what ./mk_from_bootstrap_seed does in order to go from nothing all the way up
to tcc-0.9.27.

Build kaem-optional-seed and hex0-seed
======================================
The early stages of the boostrap use the early stages of stage0-posix:

https://github.com/oriansj/stage0-posix

Specifically it uses a partial in-tree copy of stage0-posix-x86

stage0 starts with 2 binary artifacts:

hex0-seed - a commented hex dump to binary converter
kaem-optional-seed - a very simple command interpreter

I do not include the binary artifacts. I instead convert them from source to
binary using my ./mk_seeds script. The ./mk_seeds script uses a couple of
simple unix utilites to convert x86/hex0_x86.hex0 into hex0-seed and
x86/kaem-minimal.hex0 into kaem-optional-seed

Run kaem-optional-seed
======================
Next mk_from_bootstrap_seed runs kaem-optional-seed . Since
kaem-optional-seed is run with no arguments it will the by default run kaem.x86.

Build hex0
==========
This rebuilds hex0 with hex0-seed. Not strictly necessary, but just for
verification purposes it is done.

Build kaem-optional-seed
========================
This rebuilds kaem-0 with hex0-seed. Not strictly necessary, but just for
verification purposes it is done.

Build hex1 using hex0
====================
hex1 is a step up from from hex0. It adds single character absolute or relative
labels.

Build hex2 using hex1
=====================
hex2 is a step up from from hex1. It adds multi-character absolute or relative
labels.

Build catm using hex2
=====================
catm is used to concatinate files. The idea is to avoid needing any tools from
the host so we need basic things like cat. catm differs from cat as the first
argument is actually the output file (rather than the last).

Build M0 using hex2
===================
M0 is a simple macro language that allows us to implement a simple assembler. Up
until this point all programs have been provided as a hex dump of the machine
code.

The output from M0 is hex2 code. If you are aware of a typical C compilation
process you will know it tends to go:

C into C compiler outputs assembly language
Assembly Language into assembler outputs object code (machine code)
Object code into the linker then produces the final executable

Or more concisely: compile, assemble, link

In our setup M0 is the assembler and hex2 is the linker. Next step is to
build a compiler.

Build cc_x86 using M0 and hex2
==============================
cc_x86 is a C compiler written in M0 macro assembly. Lets break down the whole
build process from x86/mescc-tools-mini-kaem.kaem :

./x86/bin/M0 ./x86/cc_x86.M1 ./x86/artifact/cc_x86-0.hex2
cc_x86.M1 is the source code of the C compiler. Note the extension is actually
M1 rather than M0. M0 is just a cut down version of the M1 macro language. The
same extension is used in both cases even though cc_x86.M1 will be in the M0
subset.

This step translates the assembly language version of cc_x86 into hex2

./x86/bin/catm ./x86/artifact/cc_x86-1.hex2 ./x86/ELF-i386.hex2 ./x86/artifact/cc_x86-0.hex2
This step adds the elf header to the hex2 output. Note the output file from catm
is the first argument (./x86/artifact/cc_x86-1.hex2)

./x86/bin/hex2-0 ./x86/artifact/cc_x86-1.hex2 ./x86/bin/cc_x86
This takes the hex2 code and outputs the binary version of cc_x86

Run after.kaem
==============
Our subset of stage0 has now finished so it now executes after.kaem. From this
point forward we are starting the main part of the tcc bootstrap process that
was designed in this repo.

Build js_to_c_cc_x86.exe using cc_x86
=====================================
The initial bootstrap compiler is actually written in JavaScript. It is a JS
port of a cut down very early version of tcc. At this stage we only have a
simple C complier so we must convert this JS code to C in order to compile it.
This is what tcc_js/js_to_c.c does. The subset of JS used by tcc.js is trivially
convertable to C (think change instaces of "var" to "int", rewrite function
declarations etc).

Note many of the utilities use an exe extension. These are still Linux ELF
executables, but the exe extension was used to make it easier to gitignore so I
didn't accidentally check in binaries.

If you look in after.kaem you'll see there are about 6 steps to compiling
js_to_c_cc_x86.exe . This is because cc_x86 is just a C compiler, it is not a
"driver" program like gcc. The gcc command is actually not the C compiler, it is
the command that runs all of the compilation steps (known as a "compilation
driver"). Typically the compilation steps are:

Preprocessing (cpp, or gcc -E)
Compilation (cc1)
Assembling (as)
Linking (ld)

In the cc_x86 model thinks work like this

Concatiate together all the C source files since there is no preprocessor.
Compile the resulting file using cc_x86 to get M1 assembly
Prepend assembly definitions to M1 file, also prepend the _start function which
will be the entrypoint for the binary
Assemble the M1 file with M0 to get a hex2 file
Prepend the ELF header to the hex2 file
Convert to binary and link the hex2 file using the hex2 command.



