;; heavily cut down version of cc_x86
;; modifications Copyright (C) 2024 Liam Wilson (under same license)
;; original license
;; Copyright (C) 2017 Jeremiah Orians
;; This file is part of stage0.
;;
;; stage0 is free software: you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.
;;
;; stage0 is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with stage0.  If not, see <http://www.gnu.org/licenses/>.

DEFINE ADDI8_EAX 83C0
DEFINE ADDI8_EBX 83C3
DEFINE ADDI8_ECX 83C1
DEFINE ADDI8_EDX 83C2
DEFINE ADDI8_ESI 83C6
DEFINE ADD_eax_into_ebx 01C3
DEFINE ADD_ebx_into_eax 01D8
DEFINE ADD_ecx_into_eax 01C8
DEFINE ADD_edi_into_ecx 01F9
DEFINE AND_EAX_EBX 21D8
DEFINE ANDI32_EAX 25
DEFINE CALL_EAX FFD0
DEFINE CALL32 E8
DEFINE CMPI8_EAX 83F8
DEFINE CMPI8_EBP 83fd
DEFINE CMPI8_EBX 83FB
DEFINE CMPI8_ECX 83F9
DEFINE CMPI8_EDX 83FA
DEFINE CMPI8_ESI 83FE
DEFINE CMP_EAX_EBX 39D8
DEFINE CMP_EAX_ECX 39C8
DEFINE CMP_EBX_ECX 39D9
DEFINE CMP_ECX_EBX 39CB
DEFINE CMP_EDI_ESI 39FE
DEFINE CMP_EBX_EDX 39D3
DEFINE COPY_EAX_to_EBP 89C5
DEFINE COPY_EAX_to_EBX 89C3
DEFINE COPY_EAX_to_ECX 89C1
DEFINE COPY_EAX_to_EDX 89C2
DEFINE COPY_EAX_to_ESI 89C6
DEFINE COPY_EBP_to_EAX 89E8
DEFINE COPY_EBX_to_EAX 89D8
DEFINE COPY_EBX_to_ECX 89D9
DEFINE COPY_EBX_to_EDX 89DA
DEFINE COPY_ECX_to_EAX 89C8
DEFINE COPY_ECX_to_EBX 89CB
DEFINE COPY_EDI_to_ESI 89FE
DEFINE COPY_EDX_to_EAX 89D0
DEFINE COPY_EDX_to_EBP 89D5
DEFINE COPY_EDX_to_EBX 89D3
DEFINE COPY_ESI_to_EAX 89F0
DEFINE COPY_ESI_to_EDI 89F7
DEFINE IDIV_EBX F7FB
DEFINE IMUL_EAX_by_EBX 0FAFC3
DEFINE IMULI8_EAX 6BC0
DEFINE IMULI8_EBP 6BED
DEFINE INT_03 CC
DEFINE INT_80 CD80
DEFINE JBE8 76
DEFINE JE32 0F84
DEFINE JG32 0F8F
DEFINE JG8 7F
DEFINE JL32 0F8C
DEFINE JLE32 0F8E
DEFINE JMP32 E9
DEFINE JNE32 0F85
DEFINE LEA32_ECX_from_esp 8D0C24
DEFINE LOAD32_Absolute32_eax A1
DEFINE LOAD32_Absolute32_ebx 8B1D
DEFINE LOAD32_Absolute32_ecx 8B0D
DEFINE LOAD32_EAX_from_EAX 8B00
DEFINE LOAD32_EAX_from_EAX_Immediate8 8B40
DEFINE LOAD32_EAX_from_EBP_Immediate8 8B45
DEFINE LOAD32_EAX_from_EBX 8B03
DEFINE LOAD32_EAX_from_EBX_Immediate8 8B43
DEFINE LOAD32_EAX_from_ECX_Immediate8 8B41
DEFINE LOAD32_EAX_from_EDX_Immediate8 8B42
DEFINE LOAD32_EBP_from_EBP 8B6D00
DEFINE LOAD32_EBX_from_EAX_Immediate8 8B58
DEFINE LOAD32_EBX_from_EBX 8B1B
DEFINE LOAD32_EBX_from_EBX_Immediate8 8B5B
DEFINE LOAD32_EBX_from_ECX_Immediate8 8B59
DEFINE LOAD32_ECX_from_EAX_Immediate8 8B48
DEFINE LOAD32_ECX_from_EBX 8B0B
DEFINE LOAD32_ECX_from_ECX 8B09
DEFINE LOAD32_ECX_from_ECX_Immediate8 8B49
DEFINE LOAD32_ECX_from_EDX_Immediate8 8B4A
DEFINE LOAD32_EDI_from_EDX_Immediate8 8B7A
DEFINE LOAD32_EDX_from_EDX_Immediate8 8B52
DEFINE LOAD8_al_from_EAX 8A00
DEFINE LOAD8_al_from_EBX 8A03
DEFINE LOAD8_al_from_ECX 8A01
DEFINE LOAD8_al_from_EDX 8A02
DEFINE LOAD8_bl_from_EBX 8A1B
DEFINE LOAD8_bl_from_ECX 8A19
DEFINE LOAD8_bl_from_EDX 8A1A
DEFINE LOAD8_cl_from_EBX 8A0B
DEFINE LOAD8_cl_from_EBX_Immediate8 8A4B
DEFINE LOADI32_EAX B8
DEFINE LOADI32_EBX BB
DEFINE LOADI32_ECX B9
DEFINE LOADI32_EDI BF
DEFINE LOADI32_EDX BA
DEFINE LOADI32_ESI BE
DEFINE MOVZX_al 0FB6C0
DEFINE MOVZX_bl 0FB6DB
DEFINE MOVZX_cl 0FB6C9
DEFINE NULL 00000000
DEFINE POP_EAX 58
DEFINE POP_EBP 5D
DEFINE POP_EBX 5B
DEFINE POP_ECX 59
DEFINE POP_EDI 5F
DEFINE POP_EDX 5A
DEFINE POP_ESI 5E
DEFINE PUSH_EAX 50
DEFINE PUSH_EBP 55
DEFINE PUSH_EBX 53
DEFINE PUSH_ECX 51
DEFINE PUSH_EDI 57
DEFINE PUSH_EDX 52
DEFINE PUSH_ESI 56
DEFINE RETURN C3
DEFINE SALI8_EAX C1E0
DEFINE SHRI8_EAX C1E8
DEFINE SHRI8_EBX C1EB
DEFINE STORE32_Absolute32_eax A3
DEFINE STORE32_Absolute32_ebx 891D
DEFINE STORE32_Absolute32_ecx 890D
DEFINE STORE32_Absolute32_edx 8915
DEFINE STORE32_EAX_into_EBP_Immediate8 8945
DEFINE STORE32_EAX_into_EBX 8903
DEFINE STORE32_EAX_into_ECX_Immediate8 8941
DEFINE STORE32_EAX_into_EDX 8902
DEFINE STORE32_EAX_into_EDX_Immediate8 8942
DEFINE STORE32_EBP_into_EDX_Immediate8 896A
DEFINE STORE32_EBX_into_EAX 8918
DEFINE STORE32_EBX_into_EAX_Immediate8 8958
DEFINE STORE32_EBX_into_EDX_Immediate8 895A
DEFINE STORE32_ECX_into_EAX 8908
DEFINE STORE32_ECX_into_EAX_Immediate8 8948
DEFINE STORE32_ECX_into_EDX_Immediate8 894A
DEFINE STORE32_EDX_into_EAX_Immediate8 8950
DEFINE STORE32_EDX_into_EBP_Immediate8 8955
DEFINE STORE32_ESI_into_EBP_Immedate8 8975
DEFINE STORE32_ESI_into_EDX_Immedate8 8972
DEFINE STORE8_al_into_Address_EBX 8803
DEFINE STORE8_al_into_Address_ECX 8801
DEFINE STORE8_al_into_Address_ESI 8806
DEFINE STORE8_bl_into_Address_ECX 8819
DEFINE SUBI8_EAX 83E8
DEFINE SUBI8_ECX 83E9
DEFINE SUBI8_ESI 83EE
DEFINE SWAP_EAX_EBX 93


	;; Register usage:
	;; EAX => Temps

	;; Struct TOKEN_LIST format: (size 16)
	;; NEXT => 0
DEFINE f_NEXT 00
	;; PREV => 4
DEFINE f_PREV 04
	;; S => 8
DEFINE f_S 08

; sizeof_token_list encoded as a little endian 32 bit value
DEFINE sizeof_token_list 10000000

DEFINE MAX_STRING FF000000

; Where the ELF Header is going to hit
; Simply jump to _start
; Our main function
:_start
	POP_EAX                                     ; Get the number of arguments
	POP_EBX                                     ; Get the program name
	POP_EBX                                     ; Get the actual input name
	LOADI32_ECX %0                              ; prepare read_only
	LOADI32_EAX %5                              ; the syscall number for open()
	CALL32 %syscall
	STORE32_Absolute32_eax &Input_file          ; Preserve the file pointer we were given

	POP_EBX                                     ; Get the actual output name
	LOADI32_ECX %577                            ; Prepare file as O_WRONLY|O_CREAT|O_TRUNC
	LOADI32_EDX %384                            ; Prepare file as RW for owner only (600 in octal)
	LOADI32_EAX %5                              ; the syscall number for open()
	CALL32 %syscall

	STORE32_Absolute32_eax &Output_file         ; Preserve the file pointer we were given

	LOADI32_EAX %45                             ; the Syscall # for SYS_BRK
	LOADI32_EBX %0                              ; Get current brk
	CALL32 %syscall
	STORE32_Absolute32_eax &MALLOC              ; Set our malloc pointer
	LOADI32_EAX %0                              ; HEAD = NULL
	CALL32 %read_all_tokens                     ; Read all tokens
	CALL32 %Reverse_List                        ; Reverse order
	STORE32_Absolute32_eax &global_token        ; Set global_token
	CALL32 %program                             ; Convert into program
	LOADI32_EAX &header_string1                 ; Our header string
	CALL32 %File_Print                          ; Print it
	LOAD32_Absolute32_eax &output_list          ; Our output_list
	CALL32 %recursive_output                    ; Print core program
	LOADI32_EAX &header_string3                 ; Our second label
	CALL32 %File_Print                          ; Print it
	LOAD32_Absolute32_eax &globals_list         ; Our globals
	CALL32 %recursive_output                    ; Get them
	LOADI32_EAX &header_string4                 ; Our final header
	CALL32 %File_Print                          ; Print it
	LOAD32_Absolute32_eax &strings_list         ; Our strings
	CALL32 %recursive_output                    ; Get them
	LOADI32_EAX &header_string5                 ; Make this a bare assembly
	CALL32 %File_Print                          ; Print it

:Done
	; program completed Successfully
	LOADI32_EBX %0                              ; All is well
	LOADI32_EAX %1                              ; put the exit syscall number in eax
	CALL32 %syscall

;; wrapper around INT_80 so can be easily overridden
:syscall
	INT_80
	RETURN

;; read_all_tokens function
;; Receives Token_List* in EAX
;; Tokenizes all input and returns updated list in EAX
;; Returns TOKEN in EAX
;; Uses EAX for C
:read_all_tokens
	STORE32_Absolute32_eax &Token
	CALL32 %fgetc
:read_all_tokens_loop
	CMPI8_EAX !-4                               ; Check for EOF
	JE32 %read_all_tokens_done                  ; Stop if found
	CALL32 %get_token                           ; Read all tokens
	JMP32 %read_all_tokens_loop                 ; Loop
:read_all_tokens_done
	LOAD32_Absolute32_eax &Token
	RETURN


;; get_token function
;; Receives INT in EAX
;; Makes a list of TOKEN_LIST
;; C and STRING_INDEX are stored in memory, ECX is used for S and EDX is used for current
;; Returns C in EAX
:get_token
	PUSH_EBX                                    ; Protect EBX
	PUSH_ECX                                    ; Protect ECX
	PUSH_EDX                                    ; Protect EDX

	STORE32_Absolute32_eax &C                   ; Set C

	LOADI32_EAX sizeof_token_list               ; Malloc CURRENT
	CALL32 %malloc                              ; Get Pointer
	COPY_EAX_to_EDX                             ; Set CURRENT

	LOADI32_EAX MAX_STRING                      ; Malloc the string
	CALL32 %malloc                              ; Get pointer to S
	COPY_EAX_to_ECX                             ; Set S
	STORE32_ECX_into_EDX_Immediate8 f_S         ; CURRENT->S = S
:reset
	STORE32_Absolute32_ecx &string_index        ; S[0]
	LOAD32_Absolute32_eax &C                    ; Using C

	CALL32 %clear_white_space                   ; Clear WhiteSpace
	STORE32_Absolute32_eax &C                   ; Set C

	CMPI8_EAX !-4                               ; Check for EOF
	JE32 %get_token_abort                       ; if EOF abort

	LOAD32_Absolute32_eax &C                    ; Send C
	LOADI32_EBX &alphas                         ; Get alphanumerics
	CALL32 %In_Set                              ; See if in set
	JNE32 %get_token_symbol                     ; Otherwise

	;; Store keywords
	LOAD32_Absolute32_eax &C                    ; Send C
	CALL32 %preserve_keyword                    ; Store
	STORE32_Absolute32_eax &C                   ; Set C
	JMP32 %get_token_done                       ; Be done with this token

:get_token_symbol
	LOAD32_Absolute32_eax &C                    ; Send C
	LOADI32_EBX &symbols                        ; Get symbols
	CALL32 %In_Set                              ; See if in set
	JNE32 %get_token_comment                    ; Otherwise

	;; Store symbols
	LOAD32_Absolute32_eax &C                    ; Send C
	CALL32 %preserve_symbol                     ; Store
	STORE32_Absolute32_eax &C                   ; Set C
	JMP32 %get_token_done                       ; Be done with this token

:get_token_comment
	LOAD32_Absolute32_eax &C                    ; Send C
	CMPI8_EAX !47                               ; IF '/' == C
	JNE32 %get_token_else                       ; Otherwise

	CALL32 %consume_byte                        ; Hope it just is '/'
	STORE32_Absolute32_eax &C                   ; Set C

	CMPI8_EAX !42                               ; IF '*' we have '/*'

	;; Deal with /* block comments */
	CALL32 %fgetc                               ; get next C
	STORE32_Absolute32_eax &C                   ; Set C
:get_token_comment_block_outer
	LOAD32_Absolute32_eax &C                    ; Using C
	CMPI8_EAX !47                               ; IF '/' != C
	JE32 %get_token_comment_block_done          ; be done

:get_token_comment_block_inner
	LOAD32_Absolute32_eax &C                    ; Using C
	CMPI8_EAX !42                               ; IF '*' != C
	JE32 %get_token_comment_block_iter          ; jump over

	;; Deal with inner loop
	CALL32 %fgetc                               ; get next C
	STORE32_Absolute32_eax &C                   ; Set C
	JMP32 %get_token_comment_block_inner        ; keep going

:get_token_comment_block_iter
	CALL32 %fgetc                               ; get next C
	STORE32_Absolute32_eax &C                   ; Set C
	JMP32 %get_token_comment_block_outer

:get_token_comment_block_done
	CALL32 %fgetc                               ; get next C
	STORE32_Absolute32_eax &C                   ; Set C
	JMP32 %reset                                ; throw away, try again

:get_token_else
	LOAD32_Absolute32_eax &C                    ; Send C
	CALL32 %consume_byte
	STORE32_Absolute32_eax &C                   ; Set C

:get_token_done
	LOAD32_Absolute32_eax &Token                ; TOKEN
	STORE32_EAX_into_EDX_Immediate8 f_PREV      ; CURRENT->PREV = TOKEN
	STORE32_EAX_into_EDX                        ; CURRENT->NEXT = TOKEN
	STORE32_Absolute32_edx &Token               ; TOKEN = CURRENT

:get_token_abort
	POP_EDX                                     ; Restore EDX
	POP_ECX                                     ; Restore ECX
	POP_EBX                                     ; Restore EBX
	LOAD32_Absolute32_eax &C                    ; Return C
	RETURN


;; Malloc isn't actually required if the program being built fits in the initial memory
;; However, it doesn't take much to add it.
;; Requires [MALLOC] to be initialized and EAX to have the number of desired bytes
:malloc
	PUSH_EBX                                    ; Protect EBX
	PUSH_ECX                                    ; Protect ECX
	PUSH_EDX                                    ; Protect EDX
	LOAD32_Absolute32_ebx &MALLOC               ; Using the current pointer
	ADD_eax_into_ebx                            ; Request the number of desired bytes
	LOADI32_EAX %45                             ; the Syscall # for SYS_BRK
	CALL32 %syscall
	LOAD32_Absolute32_eax &MALLOC               ; Return pointer
	STORE32_Absolute32_ebx &MALLOC              ; Update pointer
	POP_EDX                                     ; Restore EDX
	POP_ECX                                     ; Restore ECX
	POP_EBX                                     ; Restore EBX
	RETURN


;; clear_white_space function
;; Receives INT C in EAX
;; Returns first non-whitespace char in EAX
:clear_white_space
	CMPI8_EAX !32                               ; Check for ' '
	JE32 %clear_white_space_wipe                ; wipe it out

	CMPI8_EAX !10                               ; Check for '\n'
	JE32 %clear_white_space_wipe                ; wipe it output

	CMPI8_EAX !9                                ; Check for '\t'
	JNE32 %clear_white_space_done               ; looks like non-whitespace

:clear_white_space_wipe
	CALL32 %fgetc                               ; Read a new byte
	CMPI8_EAX !-4                               ; Check for EOF
	JE32 %clear_white_space_done                ; Short circuit
	JMP32 %clear_white_space                    ; iterate

:clear_white_space_done
	RETURN


;; In_Set function
;; Receives Char C in EAX and CHAR* in EBX
;; Returns 1 if true, zero if false in EAX
:In_Set
	PUSH_EBX                                    ; Protect EBX
	PUSH_ECX                                    ; Protect ECX
:In_Set_loop
	LOAD8_cl_from_EBX                           ; Read char
	MOVZX_cl                                    ; Zero extend it

	CMP_EAX_ECX                                 ; See if they match
	JE32 %In_Set_True                           ; return true

	CMPI8_ECX !0                                ; Check for NULL
	JE32 %In_Set_False                          ; return false

	ADDI8_EBX !1                                ; s = s + 1
	JMP32 %In_Set_loop                          ; Keep looping

:In_Set_True
	LOADI32_EAX %1                              ; Set True
	JMP32 %In_Set_done

:In_Set_False
	LOADI32_EAX %0                              ; Set FALSE
:In_Set_done
	CMPI8_EAX !1                                ; make sure flags are set so we can conditionally branch straight after call
	POP_ECX                                     ; Restore ECX
	POP_EBX                                     ; Restore EBX
	RETURN

;; preserve_keyword function
;; Receives INT C in EAX
;; collects all chars in keyword
;; Returns C in EAX
;; Uses ECX for INT C
:preserve_keyword
	PUSH_EBX                                    ; Protect EBX
	PUSH_ECX                                    ; Protect ECX
	COPY_EAX_to_ECX                             ; Setup C
	LOADI32_EBX &alphas                         ; Concerning ourselves with "abc.."
:preserve_keyword_loop
	CALL32 %In_Set                              ; Check if alphanumerics
	JNE32 %preserve_keyword_done                ; Otherwise done

	COPY_ECX_to_EAX                             ; Pass C
	CALL32 %consume_byte                        ; consume that byte
	COPY_EAX_to_ECX                             ; Update C
	JMP32 %preserve_keyword_loop                ; keep looping

:preserve_keyword_done
	COPY_ECX_to_EAX                             ; Fix return
	POP_ECX                                     ; Restore ECX
	POP_EBX                                     ; Restore EBX
	RETURN


;; preserve_symbol function
;; Receives INT C in EAX
;; collects all chars in symbol
;; Returns C in EAX
;; Uses ECX for INT C
:preserve_symbol
	PUSH_EBX                                    ; Protect EBX
	PUSH_ECX                                    ; Protect ECX
	COPY_EAX_to_ECX                             ; Setup C
	LOADI32_EBX &symbols                        ; Concerning ourselves with "="
:preserve_symbol_loop
	CALL32 %In_Set                              ; Check if symbol
	JNE32 %preserve_symbol_done                 ; Otherwise be done

	COPY_ECX_to_EAX                             ; Pass C
	CALL32 %consume_byte                        ; consume that byte
	COPY_EAX_to_ECX                             ; Update C
	JMP32 %preserve_symbol_loop                 ; keep looping

:preserve_symbol_done
	COPY_ECX_to_EAX                             ; Fix return
	POP_ECX                                     ; Restore ECX
	POP_EBX                                     ; Restore EBX
	RETURN


;; consume_word function
;; receives INT C in EAX
;; returns INT C in EAX
;; Uses EAX for C, EBX for FREQ and ECX for ESCAPE
:consume_word
	PUSH_EBX                                    ; Protect EBX
	PUSH_ECX                                    ; Protect ECX
	COPY_EAX_to_EBX                             ; FREQ = C
	LOADI32_ECX %0                              ; ESCAPE = FALSE
:consume_word_loop
	CMPI8_ECX !0                                ; IF !ESCAPE
	JNE32 %consume_word_escape                  ; Enable escape

	CMPI8_EAX !92                               ; if '\\'
	JNE32 %consume_word_iter                    ; keep state

	LOADI32_ECX %1                              ; ESCAPE = TRUE
	JMP32 %consume_word_iter                    ; keep going

:consume_word_escape
	LOADI32_ECX %0                              ; ESCAPE = FALSE

:consume_word_iter
	CALL32 %consume_byte                        ; read next char

	CMPI8_ECX !0                                ; IF ESCAPE
	JNE32 %consume_word_loop                    ; keep looping

	CMP_EAX_EBX                                 ; IF C != FREQ
	JNE32 %consume_word_loop                    ; keep going

	CALL32 %fgetc                               ; return next char
	POP_ECX                                     ; Restore ECX
	POP_EBX                                     ; Restore EBX
	RETURN


;; consume_byte function
;; Receives INT C in EAX
;; Inserts C into string S, updates String S
;; Returns Next char in EAX
:consume_byte
	PUSH_EBX                                    ; Protect EBX
	LOAD32_Absolute32_ebx &string_index         ; S[0]
	STORE8_al_into_Address_EBX                  ; S[0] = C
	ADDI8_EBX !1                                ; S = S + 1
	STORE32_Absolute32_ebx &string_index        ; Update S
	CALL32 %fgetc
	POP_EBX                                     ; Restore EBX
	RETURN


;; fgetc function
;; Loads FILE* from [INPUT_FILE]
;; Returns -4 (EOF) or char in EAX
:fgetc
	PUSH_EBX                                    ; Protect EBX
	PUSH_ECX                                    ; Protect ECX
	PUSH_EDX                                    ; Protect EDX
	LOADI32_EAX %-4                             ; Put EOF in eax
	PUSH_EAX                                    ; Assume bad (If nothing read, value will remain EOF)
	LEA32_ECX_from_esp                          ; Get stack address
	LOAD32_Absolute32_ebx &Input_file           ; Where are we reading from
	LOADI32_EAX %3                              ; the syscall number for read
	LOADI32_EDX %1                              ; set the size of chars we want
	CALL32 %syscall
	POP_EAX                                     ; Get either char or EOF
	CMPI8_EAX !-4                               ; Check for EOF
	JE32 %fgetc_done                            ; Return as is
	MOVZX_al                                    ; Make it useful
:fgetc_done
	POP_EDX                                     ; Restore EDX
	POP_ECX                                     ; Restore ECX
	POP_EBX                                     ; Restore EBX
	RETURN


;; Reverse_List function
;; Receives List in EAX
;; Returns the list reversed in EAX
:Reverse_List
	PUSH_EBX                                    ; Protect EBX
	PUSH_ECX                                    ; Protect ECX
	COPY_EAX_to_EBX                             ; Set HEAD
	LOADI32_EAX %0                              ; ROOT = NULL
:Reverse_List_Loop
	CMPI8_EBX !0                                ; WHILE HEAD != NULL
	JE32 %Reverse_List_Done                     ; Stop otherwise

	LOAD32_ECX_from_EBX                         ; NEXT = HEAD->NEXT
	STORE32_EAX_into_EBX                        ; HEAD->NEXT = ROOT
	COPY_EBX_to_EAX                             ; ROOT = HEAD
	COPY_ECX_to_EBX                             ; HEAD = NEXT
	JMP32 %Reverse_List_Loop                    ; Keep Going

:Reverse_List_Done
	POP_ECX                                     ; Restore ECX
	POP_EBX                                     ; Restore EBX
	RETURN


;; recursive_output function
;; Receives list in EAX
;; walks the list and prints the I->S for all nodes backwards
;; Uses EBX for I
:recursive_output
	PUSH_EBX                                    ; Protect EBX
	PUSH_ECX                                    ; Protect ECX
	CMPI8_EAX !0                                ; Check for NULL
	JE32 %recursive_output_done                 ; Skip the work
	COPY_EAX_to_EBX                             ; I = Head

	LOAD32_EAX_from_EBX                         ; Iterate to next Token
	CALL32 %recursive_output                    ; Recurse

	LOAD32_EAX_from_EBX_Immediate8 f_S          ; Using S
	CALL32 %File_Print                          ; Print it

:recursive_output_done
	POP_ECX                                     ; Restore ECX
	POP_EBX                                     ; Restore EBX
	RETURN


;; File_Print function
;; Receives CHAR* in EAX
;; calls fputc for every non-null char
:File_Print
	PUSH_EBX                                    ; Protect EBX
	PUSH_ECX                                    ; Protect ECX
	COPY_EAX_to_EBX                             ; Protect S
	CMPI8_EAX !0                                ; Protect against nulls
	JE32 %File_Print_Done                       ; Simply don't try to print them
:File_Print_Loop
	LOAD8_al_from_EBX                           ; Read byte
	MOVZX_al                                    ; zero extend
	CMPI8_EAX !0                                ; Check for NULL
	JE32 %File_Print_Done                       ; Stop at NULL

	CALL32 %fputc                               ; write it
	ADDI8_EBX !1                                ; S = S + 1
	JMP32 %File_Print_Loop                      ; Keep going

:File_Print_Done
	POP_ECX                                     ; Restore ECX
	POP_EBX                                     ; Restore EBX
	RETURN


;; fputc function
;; receives CHAR in EAX and load FILE* from [OUTPUT_FILE]
;; writes char and returns
:fputc
	PUSH_EBX                                    ; Protect EBX
	PUSH_ECX                                    ; Protect ECX
	PUSH_EDX                                    ; Protect EDX
	PUSH_EAX                                    ; We are writing eax
	LEA32_ECX_from_esp                          ; Get stack address
	LOAD32_Absolute32_ebx &Output_file          ; Write to target file
	LOADI32_EAX %4                              ; the syscall number for write
	LOADI32_EDX %1                              ; set the size of chars we want
	CALL32 %syscall
	POP_EAX                                     ; Restore stack
	POP_EDX                                     ; Restore EDX
	POP_ECX                                     ; Restore ECX
	POP_EBX                                     ; Restore EBX
	RETURN


;; program function
;; receives nothing, returns nothing
:program
	;; The binary initialized the globals to null, so we can skip those steps
	PUSH_EBX                                    ; Protect EBX
	PUSH_ECX                                    ; Protect ECX

:new_type
	LOAD32_Absolute32_eax &global_token         ; Using global_token
	CMPI8_EAX !0                                ; Check if NULL
	JE32 %program_done                          ; Be done if null

	CALL32 %next

	;; Add to global symbol table
	CALL32 %get_s
	LOAD32_Absolute32_ecx &global_symbol_list   ; Using global_symbol_list
	CALL32 %sym_declare                         ; Declare symbol
; LJW_HACK temp symbol as we only want globals in the symbol list
	STORE32_Absolute32_eax &global_symbol_list_tmp  ; global_symbol_list_tmp
	CALL32 %next

	CALL32 %get_s
	LOADI32_EBX &semicolon                      ; ";"
	CALL32 %match                               ; if(match(";", global_token->s))
	JNE32 %program_function                     ; looks like not a match
; LJW_HACK this stores the global variable in the global_symbol_list
	LOAD32_Absolute32_ebx &global_symbol_list_tmp  ; global_symbol_list_tmp
	STORE32_Absolute32_ebx &global_symbol_list  ; global_symbol_list
	;; Deal with the global variable
	LOAD32_Absolute32_ebx &globals_list         ; Using globals_list
	LOADI32_EAX &program_string_0               ; ":GLOBAL_"
	CALL32 %emit                                ; Emit it
	COPY_EAX_to_EBX                             ; update globals_list

	LOAD32_Absolute32_eax &global_token         ; Using global token
	LOAD32_EAX_from_EAX_Immediate8 f_PREV       ; global token->prev
	LOAD32_EAX_from_EAX_Immediate8 f_S          ; global token->prev->s
	CALL32 %emit                                ; Emit it

	COPY_EAX_to_EBX                             ; update globals_list
	LOADI32_EAX &program_string_1               ; "\nNULL\n"
	CALL32 %emit                                ; Emit it
	STORE32_Absolute32_eax &globals_list        ; update globals_list

	CALL32 %next
	JMP32 %new_type                             ; go around again

:program_function

	;; Deal with function definition
	CALL32 %declare_function                    ; Lets get the parsing rolling
	JMP32 %new_type                             ; Keep looping through functions

:program_done
	POP_ECX                                     ; Restore ECX
	POP_EBX                                     ; Restore EBX
	RETURN

;; declare_function function
;; Receives nothing and returns nothing
;; Sets current function and adds it to the global function list
:declare_function
	PUSH_EBX                                    ; Protect EBX
	PUSH_ECX                                    ; Protect ECX
	LOADI32_EAX %0                              ; Using NULL

	LOAD32_Absolute32_eax &global_token         ; Using global token
	LOAD32_EAX_from_EAX_Immediate8 f_PREV       ; global token->prev
	LOAD32_EAX_from_EAX_Immediate8 f_S          ; global token->prev->s
	LOADI32_EBX %0                              ; NULL
	LOAD32_Absolute32_ecx &global_function_list ; global_function_list
	CALL32 %sym_declare                         ; sym_declare(global_token->prev->s, NULL, global_function_list);
	STORE32_Absolute32_eax &function            ; function = sym_declare(global_token->prev->s, NULL, global_function_list);
	STORE32_Absolute32_eax &global_function_list ; global_function_list = function

	CALL32 %next
	CALL32 %next

	CALL32 %get_s
	LOADI32_EBX &semicolon                      ; ";"
	CALL32 %match                               ; IF global token->s == ";"
	JNE32 %declare_function_full                ; It was a prototype

	;; Deal with prototypes
	CALL32 %next
	JMP32 %declare_function_done                ; Move on

:declare_function_full
	;; Deal with full function definitions
	LOADI32_EAX &declare_function_string_1      ; "\n:FUNCTION_"
	CALL32 %emit_out                            ; emit it

	LOAD32_Absolute32_eax &function             ; function
	LOAD32_EAX_from_EAX_Immediate8 f_S          ; function->s
	CALL32 %emit_out                            ; emit it

	CALL32 %emit_newline

	CALL32 %statement                           ; Recursively get the function pieces

	LOAD32_Absolute32_eax &output_list          ; output

	;; Add the return to the end of a function lacking a return;
	LOADI32_EAX &ret_string                     ; "ret\n"
	CALL32 %emit_out                            ; emit it

:declare_function_done
	POP_ECX                                     ; Restore ECX
	POP_EBX                                     ; Restore EBX
	RETURN

;; statement function
;; Receives nothing
;; Returns nothing
;; Walks down global_token recursively to collect the contents of the function
:statement
	PUSH_EBX                                    ; Protect EBX
	PUSH_ECX                                    ; Protect ECX

	CALL32 %get_s
	COPY_EAX_to_EBX
	LOADI32_EAX &open_curly_brace               ; "{"
	CALL32 %match                               ; IF global_token->S == "{"
	JNE32 %statement_else

	;; deal with { statement }
	CALL32 %recursive_statement                 ; Statements inside of statements for days
	JMP32 %statement_done                       ; Be done

:statement_else
	CALL32 %expression                          ; Collect expression
	CALL32 %next

:statement_done
	POP_ECX                                     ; Restore ECX
	POP_EBX                                     ; Restore EBX
	RETURN


;; recursive_statement function
;; Receives nothing
;; Returns nothing
;; Walks the global_token list to build the contents of statements
;; Uses struct token_list* frame in ECX
:recursive_statement
	PUSH_EBX                                    ; Protect EBX
	PUSH_ECX                                    ; Protect ECX

	CALL32 %next

:recursive_statement_loop
	CALL32 %get_s
	COPY_EAX_to_EBX
	LOADI32_EAX &close_curly_brace
	CALL32 %match
	JE32 %recursive_statement_cleanup           ; and then we clean up

	;; Deal with the recursive calls
	CALL32 %statement                           ; Deal with another statement
	JMP32 %recursive_statement_loop             ; loop some more

:recursive_statement_cleanup
	CALL32 %next

	POP_ECX                                     ; Restore ECX
	POP_EBX                                     ; Restore EBX
	RETURN

;; expression function
;; Receives Nothing
;; Returns Nothing
;; Walks global_token and updates output_list
;; Uses EAX and EBX for match and ECX for char* store
:expression
	PUSH_EBX                                    ; Protect EBX
	PUSH_ECX                                    ; Protect ECX
	CALL32 %primary_expr

	CALL32 %get_s
	COPY_EAX_to_EBX
	LOADI32_EAX &equal                          ; "="
	CALL32 %match                               ; IF global_token->S == "="
	JNE32 %expression_done                      ; Looks like nope

	;; Deal with possible assignment
	LOAD32_Absolute32_ebx &global_token         ; Using global_token
	LOAD32_EBX_from_EBX_Immediate8 f_PREV       ; global_token->PREV
	LOAD32_EBX_from_EBX_Immediate8 f_S          ; global_token->PREV->S

	LOADI32_EAX &expression_string_1            ; Using "push_eax\t#_common_recursion\n"
	CALL32 %emit_out                            ; Emit it

	CALL32 %next

	CALL32 %expression                          ; expression();
	LOADI32_EAX &expression_string_2            ; Using "store\n"
	CALL32 %emit_out                            ; Emit it

:expression_done
	POP_ECX                                     ; Restore ECX
	POP_EBX                                     ; Restore EBX
	RETURN

;; primary_expr function
;; Receives nothing
;; Returns nothing
:primary_expr
	PUSH_EBX                                    ; Protect EBX

	CALL32 %get_s0
	CALL32 %get_s0
	LOADI32_EBX &primary_expr_string_6          ; Using "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_"
	CALL32 %In_Set                              ; See if we have a match
	JNE32 %primary_expr_num                     ; otherwise try number

	;; Deal with variables
	CALL32 %primary_expr_variable               ; Deal with variable
	JMP32 %primary_expr_done                    ; Be done

:primary_expr_num
	CALL32 %get_s0
	LOADI32_EBX &primary_expr_string_7          ; Using "0123456789"
	CALL32 %In_Set                              ; See if we have a match

	;; Deal with numbers
	CALL32 %primary_expr_number                 ; Collect the number

:primary_expr_done
	POP_EBX                                     ; Restore EBX
	RETURN

;; primary_expr_variable function
;; Receives nothing
;; Returns nothing
;; Walks global and updates output
;; Uses EAX for struct token_list* a and ECX for char* S
:primary_expr_variable
	PUSH_EBX                                    ; Protect EBX
	PUSH_ECX                                    ; Protect ECX

	CALL32 %get_s
	COPY_EAX_to_ECX
	LOAD32_Absolute32_eax &global_token         ; Using global_token
	LOAD32_EAX_from_EAX                         ; global_token->NEXT
	STORE32_Absolute32_eax &global_token        ; global_token = global_token->NEXT

	COPY_ECX_to_EAX                             ; Using S
	LOAD32_Absolute32_ebx &global_symbol_list   ; Using global_symbol_list
	CALL32 %sym_lookup                          ; sym_lookup(s, global_function_list)
	CMPI8_EAX !0                                ; IF NULL == sym_lookup(s, global_function_list)
	JE32 %primary_expr_function                 ; try function next

	;; Deal with globals
	CALL32 %global_load                         ; Collect that global
	JMP32 %primary_expr_variable_done           ; Be done

:primary_expr_function

	;; Deal with functions (everything else is implicitly a function)
	COPY_ECX_to_EAX                             ; Using S
	CALL32 %function_call                       ; Deal with the function

:primary_expr_variable_done
	POP_ECX                                     ; Restore ECX
	POP_EBX                                     ; Restore EBX
	RETURN

;; function_call function
;; Receives char* S in EAX
;; Builds stack frames before and tears them down after function calls
;; Uses ECX for char* S, EDX for int BOOL, ESI for PASSED
:function_call
	PUSH_ECX                                    ; Protect ECX
	PUSH_EDX                                    ; Protect EDX
	PUSH_ESI                                    ; Protect ESI
	COPY_EAX_to_ECX                             ; Put S in place
	LOADI32_ESI %0                              ; PASSED = 0

	CALL32 %next

	LOADI32_EAX &function_call_string_1         ; Using "call frame preamble"
	CALL32 %emit_out                            ; Emit it

	CALL32 %get_s0

	;; All is collected
	CALL32 %next

	;; Deal with fixed function name
	LOADI32_EAX &function_call_string_9         ; Using "mov_ebp,edi call %FUNCTION_"
	CALL32 %emit_out                            ; Emit it

	COPY_ECX_to_EAX                             ; Using S
	CALL32 %emit_out                            ; Emit it

	CALL32 %emit_newline

	LOADI32_EAX &function_call_string_14        ; Using "restore ebp edi\n"
	CALL32 %emit_out                            ; Emit it

	POP_ESI                                     ; Restore ESI
	POP_EDX                                     ; Restore EDX
	POP_ECX                                     ; Restore ECX
	RETURN

;; global_load function
;; Receives struct token_list* A in EAX
;; Returns nothing
;; Uses EBX to hold A->S
:global_load
	PUSH_EBX                                    ; Protect EBX
	COPY_EAX_to_EBX                             ; Set as A
	LOAD32_EBX_from_EBX_Immediate8 f_S          ; Set as A->S

	LOADI32_EAX &global_load_string_0           ; Using "mov_eax, &GLOBAL_"
	CALL32 %emit_out                            ; Emit it

	COPY_EBX_to_EAX                             ; Using A->S
	CALL32 %emit_out                            ; Emit it

	CALL32 %emit_newline

	CALL32 %get_s
	COPY_EAX_to_EBX
	LOADI32_EAX &equal                          ; "="
	CALL32 %match                               ; IF global_token->S == "="
	JE32 %global_load_done                      ; and be done

	;; Otherwise we are loading the contents
	LOADI32_EAX &global_load_string_2           ; Using "mov_eax,[eax]\n"
	CALL32 %emit_out                            ; Emit it

:global_load_done
	POP_EBX                                     ; Restore EBX
	RETURN

;; sym_lookup function
;; Receives char* S in EAX and struct token_list* symbol_list in EBX
;; Uses I->S in EAX, S in EBX and I in ECX
;; Returns match or NULL
:sym_lookup
	PUSH_EBX                                    ; Protect EBX
	PUSH_ECX                                    ; Protect ECX
	COPY_EBX_to_ECX                             ; I = symbol_list
	COPY_EAX_to_EBX                             ; Put S in the right place
:sym_lookup_iter
	CMPI8_ECX !0                                ; IF NULL == I
	JE32 %sym_lookup_done                       ; We failed to find match

	LOAD32_EAX_from_ECX_Immediate8 f_S          ; Using I->S
	CALL32 %match                               ; IF I->S == S
	JE32 %sym_lookup_done                       ; Failed

	LOAD32_ECX_from_ECX                         ; I = I->NEXT
	JMP32 %sym_lookup_iter                      ; otherwise keep looping

:sym_lookup_done
	COPY_ECX_to_EAX                             ; Return I
	POP_ECX                                     ; Restore ECX
	POP_EBX                                     ; Restore EBX
	RETURN


;; primary_expr_number function
;; Receives nothing
;; Returns nothing
;; Simply uses current global token to update output and then steps to next global_token
:primary_expr_number
	LOADI32_EAX &constant_string                ; Using "mov_eax, %"
	CALL32 %emit_out                            ; Emit it
	CALL32 %get_s
	CALL32 %emit_out                            ; Emit it
	CALL32 %emit_newline
	CALL32 %next
	RETURN

;; next function skip to next token
;; HACK LJW this was previously require_match witch checked the token
;; Returns nothing
:next
	LOAD32_Absolute32_eax &global_token         ; Using global_token
	LOAD32_EAX_from_EAX                         ; global_token->next
	STORE32_Absolute32_eax &global_token        ; global_token = global_token->next
	RETURN

;; get string value of global_token
:get_s
	LOAD32_Absolute32_eax &global_token         ; Using global_token
	LOAD32_EAX_from_EAX_Immediate8 f_S          ; global_token->S
	RETURN

;; get first character for the string value of global_token
:get_s0
	CALL32 %get_s
	LOAD8_al_from_EAX                           ; global_token->S[0]
	MOVZX_al                                    ; Make it useful
	RETURN

;; emit_out function
;; Receives char* S in EAX
;; Returns nothing
;; Updates output_list
;; MUST NOT ALTER REGISTERS
:emit_out
	PUSH_EAX                                    ; Protect EAX
	PUSH_EBX                                    ; Protect EBX
	LOAD32_Absolute32_ebx &output_list          ; Using output_list
	CALL32 %emit                                ; emit it
	STORE32_Absolute32_eax &output_list         ; update it
	POP_EBX                                     ; Restore EBX
	POP_EAX                                     ; Restore EAX
	RETURN


;; emit function
;; Receives char *s in EAX and struct token_list* head in EBX
;; Returns struct token_list* T in EAX
:emit
	PUSH_ECX                                    ; Protect ECX
	COPY_EAX_to_ECX                             ; put S out of the way
	LOADI32_EAX sizeof_token_list               ; sizeof(struct token_list)
	CALL32 %malloc                              ; get T
	STORE32_EBX_into_EAX                        ; t->next = head;
	STORE32_ECX_into_EAX_Immediate8 f_S         ; t->s = s;
	POP_ECX                                     ; Restore ECX
	RETURN

:emit_newline
	LOADI32_EAX &newline                        ; "\n"
	CALL32 %emit_out                            ; emit it
	RETURN

;; sym_declare function
;; Receives char *s in EAX, struct type* t in EBX, and struct token_list* list in ECX
;; Returns struct token_list* in EAX
;; Uses EAX for A
:sym_declare
	PUSH_EDX                                    ; Protect EDX
	COPY_EAX_to_EDX                             ; Get char *S safely out of the way
	LOADI32_EAX sizeof_token_list               ; Using sizeof(struct token_list)
	CALL32 %malloc                              ; Get pointer to A
	STORE32_ECX_into_EAX                        ; A->NEXT = LIST
	STORE32_EDX_into_EAX_Immediate8 f_S         ; A->S = S
	POP_EDX                                     ; Restore EDX
	RETURN


;; match function
;; Receives CHAR* in EAX and CHAR* in EBX
;; Returns 0 (TRUE) or 1 (FALSE) in EAX
:match
	PUSH_EBX                                    ; Protect EBX
	PUSH_ECX                                    ; Protect ECX
	PUSH_EDX                                    ; Protect EDX
	COPY_EAX_to_ECX                             ; S1 in place
	COPY_EBX_to_EDX                             ; S2 in place
:match_Loop
	LOAD8_al_from_ECX                           ; S1[0]
	MOVZX_al                                    ; Make it useful
	LOAD8_bl_from_EDX                           ; S2[0]
	MOVZX_bl                                    ; Make it useful
	CMP_EAX_EBX                                 ; See if they match
	JNE32 %match_False                          ; If not

	ADDI8_ECX !1                                ; S1 = S1 + 1
	ADDI8_EDX !1                                ; S2 = S2 + 1
	CMPI8_EAX !0                                ; If reached end of string
	JE32 %match_Done                            ; Perfect match
	JMP32 %match_Loop                           ; Otherwise keep looping

:match_False
	LOADI32_EAX %1                              ; Return false
:match_Done
	CMPI8_EAX !0                                ; make sure flags are set so we can conditionally branch straight after match
	POP_EDX                                     ; Restore EDX
	POP_ECX                                     ; Restore ECX
	POP_EBX                                     ; Restore EBX
	RETURN

;; Frequently Used strings
:open_curly_brace  "{"
:close_curly_brace  "}"
:open_paren  "("
:close_paren  ")"
:semicolon  ";"
:equal  "="
:newline  "
"
:underline  "_"

;; function strings
:header_string1  "
# Core program
"
:header_string3  "
# Program global variables
"
:header_string4  "
# Program strings
"
:header_string5  "
:ELF_end
"

;; Strings needed by the program function
:program_string_0  ":GLOBAL_"
:program_string_1  "
NULL
"

:declare_function_string_1  "
:FUNCTION_"
:ret_string  "ret
"

:pop_ebx_string  "pop_ebx
"
:jump_string  "jump %"

:expression_string_1  "push_address
"
:expression_string_2  "store
"

:function_call_string_1  "(
"
:function_call_string_4  "push_arg
"
:function_call_string_9  "do_call %FUNCTION_"
:function_call_string_14 ")
"

:global_load_string_0  "global &GLOBAL_"
:global_load_string_2  "load
"

:primary_expr_string_6  "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_"
:primary_expr_string_7  "0123456789"

:constant_string  "constant %"

:alphas  "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz"
:symbols  "="

:C
	NULL
:Input_file
	NULL
:MALLOC
	NULL
:Output_file
	NULL
:Token
	NULL
:function
	NULL
:global_function_list
	NULL
:global_symbol_list
	NULL
:global_symbol_list_tmp
	NULL
:global_token
	NULL
:global_types
	&prim_types
:globals_list
	NULL
:output_list
	NULL
:string_index
	NULL
:strings_list
	NULL

:ELF_end
