Alternative bootstrap path using a heavily cut down version of M2-Planet rather
than cc_x86. The cut down version of M2-Planet is called M2_simple_asm.c . This
cut down version supports a very small subset of C (no operators other than =,
simple expressions only, no structs, enums, etc etc, more complete description
of this subset further down this page).

Building:
========

In the parent directory run:

./mk_otccelf

This runs the full tcc bootstrap path, but it also generates some files/tools
that we depend on (temp hack the final version will have its own build script).

Next run:

./mk_simple_asm_self

in the m2min directory. This will use M2_simple_asm.M1 to rebuild itself by
rebuilding M2_simple_asm.c (plus simple_support_m2.c). The resulting binary
(artifacts/M2_simple_asm_m2.exe) is then used to build a copy of otccelf. The
bootstrap process builds bit identical copies of M2_simple_asm.M1 and otccelf.
This can be verified using the following alternative paths:

./mk_simple_asm (builds M2_simple_asm.M1 from M2_simple_asm.c using both tcc
                 and gcc)
./mk_simple_asm_cc_x86 (builds using cc_x86)

mk_simple_asm_self only depends on the availability of hex2 and M0 (which are
built by mk_otccelf and deposited in ../x86/bin/).

Note M2_simple_asm.M1 is a checked in copy of the build artifact generated by
combining both M2_simple_asm.c and simple_support_m2.c and compiling itself.
M2_simple_asm has been adapted to output a simplified assembly language which
is (hopefully) fairly easy to cross referernce with the C source code. See
further down this document for a more detailed description of the assembly
language dialect.

Bootstrap path
==============

Currently incomplete, but the general plan will be:

hex0 -> hex1 -> hex2 -> M0 -> M2_simple_asm.M1 -> otccelf (DONE)
M2_simple_asm then is used to build M2_tcc.c (TODO port this to the
M2_simple_asm dialect).
M2_tcc build tcc.js and then the standard tcc_bootstrap_alt bootstrap process
continues from here up to tcc-0.9.27

otccelf will then be used to build loaders to run the rest of the steps since
this allows dynamic linking to glibc (which speeds up the bootstrap process
and allows us to generate binaries that can call into system libraries on a
stock Linux distro). At a later date I'll probably add the ability to statically
link to a polyfill libc like ../mk_from_bootstrap_seed can.

Note I originally planned to use otccelf to build tcc.js, but I found that
otccelf will miscompile it (see ../otccelf/mk_js_to_c_alt).

C dialect
=========

Using an example:

int copy_string(int target, int source, int max) {
        int i;
        i = 0;
        while(neq(0, ri8(add(source, i)))) {
                wi8(add(target, i), ri8(add(source, i)));
                i = add(i, 1);
                if(eq(i, max)) {
                        break;
                }
        }
}

From the above snippet you will notice that there are:

No operators (other than assignment, hence "add" function above)
Only available type is the int.
wi8 and ri8 are 8 bit integer write and read instructions respectively (no array
indexing, pointer manipulation etc)
No comparison operators either (neq is equivalent to !=)

There are many other restrictions eg:

No for loops (use while instead)

There are also some bugs eg:

Strings cannot include the double quote character even if it is quotes eg:
"\"" is not a vaild string (it will compile, but it will silently fail when
passed into M0/hex2. To work around this you must insert the ascii code manually
into your string (eg with wi8('"') ).


Assembly dialect
================

See also simple_asm_defs.M1 for the definitions of all available "instructions"
(each "instruction" is actually a short sequence of x86 instructions).

Using copy_string as an example. Note this is only part of the function since
the M1 code is more verbose:

:FUNCTION_copy_string
  DEFINE ARG_max F4FFFFFF
  DEFINE ARG_source F8FFFFFF
  DEFINE ARG_target FCFFFFFF
  DEFINE LOCAL_i ECFFFFFF
  reserve_stack_slot
  local LOCAL_i push_address
  constant %0 store
:WHILE_copy_string_0
  ( constant %0 push_arg
    ( ( local ARG_source load push_arg
        local LOCAL_i load push_arg
        do_call %FUNCTION_add cleanup_args_bytes %8
      )
      push_arg
      do_call %FUNCTION_ri8 cleanup_args_bytes %4
    )
    push_arg
    do_call %FUNCTION_neq cleanup_args_bytes %8
  )
  jump_false %END_WHILE_copy_string_0
....
  cleanup_locals_bytes %4 ret


This is still standard M1 code, but with different DEFINE values. There are
about 16 "instructions" defined in simple_asm_defs.M1 . Hopefully the above is
fairly self descriptive, but just for clarity:

The open paren "(" is used to indicate that we are preparing to call a
function.
The close parent ")" indicates we have completelly finished calling a function.
"local" means load the address of the following local variable (there is also
"global" for global variable).
"load" will load a variable into the accumulator
"push_arg" will push the accumulator onto the stack
"do_call" will call the function that follows.
"cleanup_args_bytes" cleans up any stack variables that were allocated for the
function call.
"push_address" will push an address onto the stack. Technically this is no
different to "push_arg" but a different name is used to distingush between
operations.
"constant" will store the following 32 bit value in the accumulator
"store" will pop an address off the stack and store the accumulator into that
address.
"jump_false" relative jump if the accumulator contains false. This is the only
conditional jump supported. All other comparisons are done via calls to
various "primitives" (eg lt for less than etc).
"jump" is an unconditional jump.
"cleanup_locals_bytes" is a stack cleanup opcode that pops all the allocated
local variables off the stack
"ret" is just the x86 return opcode. Not actually defined in simple_asm_defs.M1
but actually defined in x86_defs.M1. Should really be migrated.
"reserve_stack_slot" reserves space for 1 local variable

Note all symbols prefixed with & mean insert the 32 bit absolute address of the
following symbol. The symbols prefixed with % mean insert the relative 32 bit
offset of this symbol. % followed by a number is a 32 bit signed integer in base
10.

The DEFINE token means insert the second symbol when you encounter the first.
eg:

  DEFINE ARG_max F4FFFFFF

means insert F4FFFFFF whenever you encounter ARG_max. This is how we do
named local variables. We rely on the fact we can redefine these macro DEFINEs
in each function to give the frame relative address of each local
value/argument.

Calling convention is the same as M2-Planet, but disguised by the very different
notation.

In the above example:

  DEFINE ARG_max F4FFFFFF
  DEFINE ARG_source F8FFFFFF
  DEFINE ARG_target FCFFFFFF
  DEFINE LOCAL_i ECFFFFFF
  reserve_stack_slot

is defining the frame layout. This allows us to use named local variable rather
than numerical stack offsets. The values in these defines are hex encoded 32 bit
little endian offsets from the frame pointer (eg ARG_target is -4 bytes from the
frame pointer (the ebp register is the frame pointer on x86)).

Stack grows downwards on x86.

In the above example we can see that there is a 4 byte gap between LOCAL_i and
the lowest arg (ARG_max). This is because the return instruction pointer is
saved after the arguments.

The above example also includes an example of writing a value to a local
variable:

  local LOCAL_i push_address
  constant %0 store

If we translate this into x86 assembly we can see what is happening:

# local LOCAL_i
lea_eax,[ebp+DWORD] ECFFFFFF
(calculate the address of LOCAL_i and store that address in eax)

# push_address
push_eax
(push eax onto the stack)

# constant %0
mov_eax, %0
(store the value 0 into eax)

# store
pop_ebx (pop the top of stack into ebx, this will be the address of LOCAL_i)
mov_[ebx],eax (store eax into the memory location given by ebx)

As you can see from the above example we also have "primitives" (like add) that
provide basic arithmetic and logic operations that would normally be built in to
a compiler. For example this is the code for "add" (from simple_support_m2.c):

int add(int a, int b){
/*      return a + b; */
        asm(
                "lea_eax,[ebp+DWORD] %-4"
                "mov_eax,[eax]"
                "push_eax"
                "lea_eax,[ebp+DWORD] %-8"
                "mov_eax,[eax]"
                "pop_ebx"
                "add_eax,ebx"
                "ret"
        );
}

The above assembly language implementation was generated by a full version of M2
and then checked in to the codebase (could have also been hand written).
M2_simple_asm still supports the asm statement and so can include arbitrary asm
code if necessary.
